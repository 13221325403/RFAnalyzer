package com.mantz_it.rfanalyzer;

import android.util.Log;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

/**
 * <h1>RF Analyzer - File Source of IQ samples</h1>
 *
 * Module:      FileIQSource.java
 * Description: Simple source of IQ sampling by reading from IQ files generated by the
 *              HackRF. Just for testing.
 *
 * @author Dennis Mantz
 *
 * Copyright (C) 2014 Dennis Mantz
 * License: http://www.gnu.org/licenses/gpl.html GPL version 2 or higher
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */
public class FileIQSource implements IQSourceInterface {
	private boolean repeat = false;
	private int sampleRate = 0;
	private int packetSize = 0;
	private byte[] buffer = null;
	private File file = null;
	private BufferedInputStream bufferedInputStream = null;
	private static final String logtag = "FileIQSource";

	public FileIQSource(File file, int sampleRate, int packetSize, boolean repeat) {
		this.file = file;
		this.repeat = repeat;
		this.sampleRate = sampleRate;
		this.packetSize = packetSize;
		this.buffer = new byte[packetSize];
	}

	@Override
	public int getSampleRate() {
		return sampleRate;
	}

	@Override
	public int getPacketSize() {
		return packetSize;
	}

	@Override
	public byte[] getPacket(int timeout) {
		if(bufferedInputStream == null)
			return null;

		// Simulate sample rate of real hardware:
		try {
			Thread.sleep(packetSize/sampleRate * 1000);
		} catch (InterruptedException e) {
			Log.w(logtag, "getPacket: Interrupted while sleeping!");
		}

		try {
			if(bufferedInputStream.read(buffer, 0 , buffer.length) != buffer.length) {
				if(repeat) {
					// rewind and try again:
					bufferedInputStream.close();
					this.bufferedInputStream = new BufferedInputStream(new FileInputStream(file));
					if (bufferedInputStream.read(buffer, 0, buffer.length) != buffer.length)
						return null;
				} else
					return null;
			}
		} catch (IOException e) {
			Log.e(logtag,"getPacket: Error while reading from file: " + e.getMessage());
		}

		return buffer;
	}

	@Override
	public void returnPacket(byte[] buffer) {
		// do nothing
	}

	@Override
	public void startSampling() {
		// open the file
		try {
			this.bufferedInputStream = new BufferedInputStream(new FileInputStream(file));
		}catch (IOException e) {
			Log.e(logtag, "startSampling: Error while opening file: " + e.getMessage());
		}
	}

	@Override
	public void stopSampling() {
		// close the file
		try {
			if(bufferedInputStream != null)
				bufferedInputStream.close();
		} catch (IOException e) {
			Log.e(logtag, "stopSampling: Error while closing file: " + e.getMessage());
		}
	}

	@Override
	public int fillPacketIntoSamplePacket(byte[] packet, SamplePacket samplePacket, int startIndex) {
		/**
		 * The HackRF delivers samples in the following format:
		 * The bytes are interleaved, 8-bit, signed IQ samples (in-phase
		 *  component first, followed by the quadrature component):
		 *
		 *  [--------- first sample ----------]   [-------- second sample --------]
		 *         I                  Q                  I                Q ...
		 *  receivedBytes[0]   receivedBytes[1]   receivedBytes[2]       ...
		 */
		int count = 0;
		double[] re = samplePacket.re();
		double[] im = samplePacket.im();
		for (int i = 0; i < packet.length; i+=2) {
			re[startIndex+count] = packet[i] / 128.0;
			im[startIndex+count] = packet[i+1] / 128.0;
			count++;
			if(startIndex+count >= samplePacket.size())
				break;
		}
		return count;
	}
}
